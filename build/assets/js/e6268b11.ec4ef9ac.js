"use strict";(self.webpackChunkopensource_website=self.webpackChunkopensource_website||[]).push([[9618],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),b=r,m=u["".concat(l,".").concat(b)]||u[b]||d[b]||i;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=b;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},4733:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:6},s="6. Event-Distributor",o={unversionedId:"help/Tutorials/nodejs/basics/event-distributor",id:"help/Tutorials/nodejs/basics/event-distributor",title:"6. Event-Distributor",description:"The NoPE-Dispatcher uses one eventDistributor. The EventDistributor essentially represents a PubSubSystem. It distributes events over the network (or internally). The eventDistributor is essentially a PubSubSystem and can be used to listen for specific events.",source:"@site/docs/help/Tutorials/nodejs/03-basics/06-event-distributor.md",sourceDirName:"help/Tutorials/nodejs/03-basics",slug:"/help/Tutorials/nodejs/basics/event-distributor",permalink:"/docs/help/Tutorials/nodejs/basics/event-distributor",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"5. Connectivity Manager",permalink:"/docs/help/Tutorials/nodejs/basics/connectivity-manager"},next:{title:"7. Data-Distributor",permalink:"/docs/help/Tutorials/nodejs/basics/data-distributor"}},l={},p=[{value:"PubSubSystem",id:"pubsubsystem",level:2},{value:"An Event",id:"an-event",level:2},{value:"Interact with the EventDistributor:",id:"interact-with-the-eventdistributor",level:2},{value:"Topics in a PubSubSystem",id:"topics-in-a-pubsubsystem",level:3},{value:"Connectes Pub-Sub-Systems",id:"connectes-pub-sub-systems",level:3},{value:"Using EventEmitter instead of callbacks",id:"using-eventemitter-instead-of-callbacks",level:3}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"6-event-distributor"},"6. Event-Distributor"),(0,r.kt)("p",null,"The NoPE-Dispatcher uses one ",(0,r.kt)("inlineCode",{parentName:"p"},"eventDistributor"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"EventDistributor")," essentially represents a ",(0,r.kt)("inlineCode",{parentName:"p"},"PubSubSystem"),". It distributes events over the network (or internally). The ",(0,r.kt)("inlineCode",{parentName:"p"},"eventDistributor")," is essentially a ",(0,r.kt)("inlineCode",{parentName:"p"},"PubSubSystem")," and can be used to listen for specific events. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"PubSubSystem")," keeps a so called root object (essentially any data object). Data can be ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribed")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"published")," by means of so-called topics. The topics follow the ",(0,r.kt)("inlineCode",{parentName:"p"},"mqtt")," patterns. While MQTT only allows subscriptions with so-called ",(0,r.kt)("strong",{parentName:"p"},"single-level wildcards")," and ",(0,r.kt)("strong",{parentName:"p"},"multi-level wildcards"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"PubSubSystem")," can also use them to publish data / changes."),(0,r.kt)("h2",{id:"pubsubsystem"},"PubSubSystem"),(0,r.kt)("p",null,"The system consists of ",(0,r.kt)("inlineCode",{parentName:"p"},"Publishers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Subscribers"),", which are connected by ",(0,r.kt)("inlineCode",{parentName:"p"},"Topics")," (based on ",(0,r.kt)("inlineCode",{parentName:"p"},"strings"),")."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To add new ",(0,r.kt)("inlineCode",{parentName:"li"},"Publishers")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Subscribers")," use the function: ",(0,r.kt)("inlineCode",{parentName:"li"},"register")," and specify the required options."),(0,r.kt)("li",{parentName:"ul"},"To add new ",(0,r.kt)("inlineCode",{parentName:"li"},"subscribers")," you can use the function: ",(0,r.kt)("inlineCode",{parentName:"li"},"registerSubscription")," which will get a subject and a ",(0,r.kt)("inlineCode",{parentName:"li"},"callback"),"."),(0,r.kt)("li",{parentName:"ul"},"After adding ",(0,r.kt)("inlineCode",{parentName:"li"},"publishers")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"subscribers")," you can change the behavior with ",(0,r.kt)("inlineCode",{parentName:"li"},"updateOptions"),"."),(0,r.kt)("li",{parentName:"ul"},"To remove ",(0,r.kt)("inlineCode",{parentName:"li"},"publishers")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"subscribers")," use ",(0,r.kt)("inlineCode",{parentName:"li"},"unregister"),"."),(0,r.kt)("li",{parentName:"ul"},"to ",(0,r.kt)("inlineCode",{parentName:"li"},"emit")," data use ",(0,r.kt)("inlineCode",{parentName:"li"},"emit"),"."),(0,r.kt)("li",{parentName:"ul"},"internally, when a subscriber / publisher is added, its options are changed or it is removed, the pub subsystem updates an appropriate structure. In case you want to do this manually, run"),(0,r.kt)("li",{parentName:"ul"},"to check which ",(0,r.kt)("inlineCode",{parentName:"li"},"publishers")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"subscribers")," exist, and check the appropriate properties."),(0,r.kt)("li",{parentName:"ul"},"You can subscribe to incremental changes using the eventEmitter."),(0,r.kt)("li",{parentName:"ul"},"When the pub subsystem is no longer needed, ",(0,r.kt)("inlineCode",{parentName:"li"},"dispose")," the system!"),(0,r.kt)("li",{parentName:"ul"},"Incremental data changes are published to ",(0,r.kt)("inlineCode",{parentName:"li"},"onIncrementalDataChange"),". This is an ",(0,r.kt)("inlineCode",{parentName:"li"},"EventEmitter")," that contains the incremental data change. This is triggered when a publisher changes its data. The emitter contains only the last sent data and the topic.")),(0,r.kt)("p",null,"A publisher can be an ",(0,r.kt)("inlineCode",{parentName:"p"},"observabes")," or an ",(0,r.kt)("inlineCode",{parentName:"p"},"eventEmitters"),". "),(0,r.kt)("p",null,"In order to distribute the events to the different ",(0,r.kt)("inlineCode",{parentName:"p"},"EventDistributors")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"NoPE"),", they are linked by ",(0,r.kt)("inlineCode",{parentName:"p"},"Bridge")," and forward the all changes (see ",(0,r.kt)("inlineCode",{parentName:"p"},"onIncrementalDataChange"),")."),(0,r.kt)("h2",{id:"an-event"},"An Event"),(0,r.kt)("p",null,"A event is not persisent. Once it is fired the ",(0,r.kt)("inlineCode",{parentName:"p"},"event-listeners")," will be informed. There is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"no"))," historic access to events. If you subscribed after the Event has been fired, you wont get"),(0,r.kt)("h2",{id:"interact-with-the-eventdistributor"},"Interact with the EventDistributor:"),(0,r.kt)("p",null,"Firstly we have to create a Dispatcher, that we are using to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"eventDistributor")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// First lets install nope using npm\nimport * as nope from "nope-js-node";\n\n// Create a communicator:\n// We will use the event layer (which just runs internally)\nconst communicator = nope.getLayer("event");\n\n// Lets create our dispatcher\n\n// 1. Dispatcher simulates our local system\nconst localDispatcher = nope.dispatcher.getDispatcher({\n  communicator,\n  id: "local"\n}, {\n  singleton: false,\n  useBaseServices: false\n});\n\n// Lets wait for our element to be ready.\nawait localDispatcher.ready.waitFor();\n')),(0,r.kt)("h3",{id:"topics-in-a-pubsubsystem"},"Topics in a PubSubSystem"),(0,r.kt)("p",null,"The Distributor uses Wildcards. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"+")," is a so-called ",(0,r.kt)("strong",{parentName:"li"},"single-level wildcard")," and "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#")," is a so-called ",(0,r.kt)("strong",{parentName:"li"},"multi-level wildcard"),". ")),(0,r.kt)("p",null,"While a ",(0,r.kt)("strong",{parentName:"p"},"single-level wildcard")," can be used on all levels of a topic, a ",(0,r.kt)("strong",{parentName:"p"},"multi-level wildcard")," can only be used at the end (otherwise this is a syntax-error)."),(0,r.kt)("p",null,"The symbol ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," is used as ",(0,r.kt)("strong",{parentName:"p"},"level separator"),". This is always the same within Nope."),(0,r.kt)("p",null,"In the example, the following JSON object is published on ",(0,r.kt)("inlineCode",{parentName:"p"},"''")," (an empty topic):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "foo1": ["bar1", "baz2"],\n    "foo2": ["bar2", "baz2"],\n}\n')),(0,r.kt)("p",null,"Then the following Topic strings can be ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribed")," to get the associated values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'""         -> // the entire object\n"foo1"     -> // ["bar1", "baz1"]\n"foo1/0"   -> // "bar1"\n"+/0"      -> // ["bar1", "bar2"]\n"+/+"      -> // ["bar1", "bar2", "baz1", "baz2"]\n"#",       -> // [{"foo1": ["bar1", "baz2"]}, {"foo2": ["bar2", "baz2"]}, "bar1", "bar2", "baz1", "baz2"\n')),(0,r.kt)("p",null,"Lets test that in our example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// We firstly create our subscriptions:\n\nlet observers = [];\n\nconst toSubscribe = [\n    "",\n    "foo1",\n    "foo1/0",\n    "foo2",\n    "foo2/0",\n    "+/0",      // Singlelevel wildcards\n    "+/+",      // Singlelevel wildcards\n    "#"         // multilevel wildcard\n]\n\n// A function to add some extra space in a string:\nfunction renderTopic(s, _size){\n    s = "\'" + s + "\'";\n    while (s.length < _size) {\n        s = " " + s;\n    }\n    return s;\n}\n\n// Now subscribe the topics of toSubscribe\nfor (const [idx,topic] of toSubscribe.entries()){\n    observers.push(\n        localDispatcher.eventDistributor.registerSubscription(topic, (data, rest) => {\n            console.log(idx," - "+renderTopic(topic,8)+" received " + JSON.stringify(data))\n        })\n    );\n}\n')),(0,r.kt)("p",null,"After we have defined the elements to subscribe the content, we now are able to publish some content and identify, which observer gets informed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'localDispatcher.eventDistributor.emit("",{\n    "foo1": ["bar1", "baz2"],\n    "foo2": ["bar2", "baz2"],\n});\n')),(0,r.kt)("p",null,"This results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'0  -       \'\' received {"foo1":["bar1","baz2"],"foo2":["bar2","baz2"]}\n1  -   \'foo1\' received ["bar1","baz2"]\n2  - \'foo1/0\' received "bar1"\n3  -   \'foo2\' received ["bar2","baz2"]\n4  - \'foo2/0\' received "bar2"\n5  -    \'+/0\' received [{"path":"foo1/0","data":"bar1"},{"path":"foo2/0","data":"bar2"}]\n6  -    \'+/+\' received [{"path":"foo1/0","data":"bar1"},{"path":"foo1/1","data":"baz2"},{"path":"foo2/0","data":"bar2"},{"path":"foo2/1","data":"baz2"}]\n7  -      \'#\' received [{"path":"foo1","data":["bar1","baz2"]},{"path":"foo1/0","data":"bar1"},{"path":"foo1/1","data":"baz2"},{"path":"foo2","data":["bar2","baz2"]},{"path":"foo2/0","data":"bar2"},{"path":"foo2/1","data":"baz2"}]\n')),(0,r.kt)("p",null,"As you can see using this structure, all subscriptions get informed."),(0,r.kt)("p",null,"Not let's change the emitting event to ",(0,r.kt)("inlineCode",{parentName:"p"},"'foo1'")," and adapt the data to see which observer receives the info:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'localDispatcher.eventDistributor.emit("foo1",[1,2,3,4,5]);\n')),(0,r.kt)("p",null,"This results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'0  -       \'\' received {"foo1":[1,2,3,4,5],"foo2":["bar2","baz2"]}\n1  -   \'foo1\' received [1,2,3,4,5]\n7  -      \'#\' received [1,2,3,4,5]\n2  - \'foo1/0\' received 1\n5  -    \'+/0\' received [{"path":"foo1/0","data":1}]\n6  -    \'+/+\' received [{"path":"foo1/0","data":1},{"path":"foo1/1","data":2},{"path":"foo1/2","data":3},{"path":"foo1/3","data":4},{"path":"foo1/4","data":5}]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'localDispatcher.eventDistributor.emit("foo1/0","test");\n')),(0,r.kt)("p",null,"This results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'0  -       \'\' received {"foo1":["test",2,3,4,5],"foo2":["bar2","baz2"]}\n1  -   \'foo1\' received ["test",2,3,4,5]\n2  - \'foo1/0\' received "test"\n5  -    \'+/0\' received "test"\n6  -    \'+/+\' received "test"\n7  -      \'#\' received "test"\n')),(0,r.kt)("p",null,"Now we will send an event that is not subscribed. This should only inform : "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"''")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'localDispatcher.eventDistributor.emit("eventName","eventData");\n')),(0,r.kt)("p",null,"Results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'0  -       \'\' received {"foo1":["test",2,3,4,5],"foo2":["bar2","baz2"],"eventName":"eventData"}\n7  -      \'#\' received "eventData"\n')),(0,r.kt)("h3",{id:"connectes-pub-sub-systems"},"Connectes Pub-Sub-Systems"),(0,r.kt)("p",null,"We will add an additional dispatcher, to show how multiple eventDistributors work together. This additional dispatcher is created manually but simulates an extra runtime on a different computing node."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// 2. Dispatcher simulates our remote system\nconst remoteDispatcher = nope.dispatcher.getDispatcher({\n  communicator,\n  id: "remote"\n}, {\n  singleton: false,\n  useBaseServices: false\n});\n\n')),(0,r.kt)("p",null,"Now we wait for our dispatcher to be ready."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Lets wait for our element to be ready.\nawait remoteDispatcher.ready.waitFor();\n")),(0,r.kt)("p",null,"Now we want to use our ",(0,r.kt)("inlineCode",{parentName:"p"},"eventDistributor")," to emit Events instead of the local one. Therefore we will create different subscriptions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'remoteDispatcher.eventDistributor.emit("test/event", {hello: "World"});\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'0  -       \'\' received {"foo1":["test",2,3,4,5],"foo2":["bar2","baz2"],"eventName":"eventData","test":{"event":{"hello":"World"}}}\n6  -    \'+/+\' received {"hello":"World"}\n7  -      \'#\' received {"hello":"World"}\n')),(0,r.kt)("h3",{id:"using-eventemitter-instead-of-callbacks"},"Using EventEmitter instead of callbacks"),(0,r.kt)("p",null,"Instead of using the functions ",(0,r.kt)("inlineCode",{parentName:"p"},"emit")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"registerSubscription")," we can use the method ",(0,r.kt)("inlineCode",{parentName:"p"},"register"),", to register ",(0,r.kt)("inlineCode",{parentName:"p"},"EventEmitter")," directly. This mechanism is used for modules, containing eventEmitters. "),(0,r.kt)("p",null,"Let's show this in an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// Create a Publisher and Subscriber\nlet emitter_01 = new nope.NopeEventEmitter();\nlet emitter_02 = new nope.NopeEventEmitter();\n\n// Now we create some extra Subscriptions for these emitters:\nemitter_01.subscribe((data) => {\n    console.log("Subscription on emitter_01 received =",data)\n});\nemitter_02.subscribe((data) => {\n    console.log("Subscription on emitter_02 received =",data)\n});\n\n// Now we register them at the dispatchers:\n\nremoteDispatcher.eventDistributor.register(emitter_01, {\n   // we could receive and emit events:\n   mode: ["publish", "subscribe"],\n   topic: "this/is/an/example", \n});\n\nlocalDispatcher.eventDistributor.register(emitter_02, {    \n   // we could receive and emit events:\n   mode: ["subscribe"],\n   topic: "this/is/an/example", \n});\n\n// We now want to see the subscribed events:\nconst subscribers = localDispatcher.eventDistributor.subscriptions.data.getContent();\nconst publishers = localDispatcher.eventDistributor.publishers.data.getContent();\n\nconsole.log("subscribers = ",subscribers);\nconsole.log("publishers = ",publishers)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"subscribers =  [\n  '',\n  'foo1',\n  'foo1/0',\n  'foo2',\n  'foo2/0',\n  '+/0',\n  '+/+',\n  '#',\n  'this/is/an/example'\n]\n\npublishers =  [ false ]\n")),(0,r.kt)("p",null,"As we expected, we are getting all subscribers, including the ones from above.\nCurrently only 1 fix publisher is known. Using the method ",(0,r.kt)("inlineCode",{parentName:"p"},"emit")," wont create\nan emitter.    "),(0,r.kt)("p",null,"By utilizing the same topics (here ",(0,r.kt)("inlineCode",{parentName:"p"},"'this/is/an/example'"),") those elements are linked.\nAdditionally, we defined, that the system is capable of publish and subscribe on the\nsame topics. this enables the emitters to emit and receive events from external elements."),(0,r.kt)("p",null,"We now exchange some events."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// For better readability we remove our old subscriptions:\n\nfor (const obs of observers){\n    obs.unsubscribe();\n}\n\nobservers = [];\n\nemitter_01.emit("shared")\n')),(0,r.kt)("p",null,"Emitting the Event results in calling both subscribers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Subscription on emitter_01 received = shared\nSubscription on emitter_02 received = shared\n")),(0,r.kt)("p",null,"This works for more complex data as well.\nBescause our emitter_02 only is capable to receive data (see above, the mode was set to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),") events wont be send to other dispatchers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'emitter_02.emit({complex:"data"})\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Subscription on emitter_02 received = { complex: 'data' }\n")),(0,r.kt)("p",null,"Only the subscription of emitter_02 received the data change. This same holds for the mode ",(0,r.kt)("inlineCode",{parentName:"p"},"publish"),". Thoses emitters wont receive external signals."))}d.isMDXComponent=!0}}]);