"use strict";(self.webpackChunkopensource_website=self.webpackChunkopensource_website||[]).push([[3150],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||r;return n?a.createElement(u,s(s({ref:t},p),{},{components:n})):a.createElement(u,s({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8224:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:5},s="5. Connectivity Manager",o={unversionedId:"help/Tutorials/nodejs/basics/connectivity-manager",id:"help/Tutorials/nodejs/basics/connectivity-manager",title:"5. Connectivity Manager",description:"The NoPE-Dispatchers uses one ConnectivityManager. The manager observes the connection and remotely connected dispatchers (via their ConnectivityManager).",source:"@site/docs/help/Tutorials/nodejs/03-basics/05-connectivity-manager.md",sourceDirName:"help/Tutorials/nodejs/03-basics",slug:"/help/Tutorials/nodejs/basics/connectivity-manager",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/connectivity-manager",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"4. Create a Dispatcher",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/create-dispatcher"},next:{title:"6. Event-Distributor",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/event-distributor"}},l={},c=[{value:"Summary",id:"summary",level:2},{value:"Details",id:"details",level:2},{value:"Master",id:"master",level:2},{value:"Synchronizing time",id:"synchronizing-time",level:2},{value:"Working with a ConnectivityManager",id:"working-with-a-connectivitymanager",level:2}],p={toc:c},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"5-connectivity-manager"},"5. Connectivity Manager"),(0,i.kt)("p",null,"The NoPE-Dispatchers uses one ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager"),". The manager observes the connection and remotely connected dispatchers (via their ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager"),")."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"The Manager detects newly connected dispatchers and disconnected dispatchers. Additionally, it sends a StatusMessage (in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"INopeStatusInfo"),"). This status message is interpreted as heartbeat. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager")," checks those heartbeats with a defined interval. If a specific amount of time is ellapsed, the remote dispatcher is marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"slow")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"warning")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"dead"),". After an additional delay in the state ",(0,i.kt)("inlineCode",{parentName:"p"},"dead")," the dispatcher is altough removed."),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," observes the connection to various dispatchers. This element displays all found dispatchers in the network (if there are no others only itself) in the ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatchers")," property. It manages the status (",(0,i.kt)("inlineCode",{parentName:"p"},"dead"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"slow"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"warn"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"alive"),") of the other dispatchers. "),(0,i.kt)("p",null,"The manager uses a ",(0,i.kt)("a",{parentName:"p",href:"/NoPE-Docs/docs/help/Tutorials/nodejs/advanced/bridge"},(0,i.kt)("inlineCode",{parentName:"a"},"bridge"))," to search for new dispatchers. When a layer connection is established via the bridge, a so-called ",(0,i.kt)("inlineCode",{parentName:"p"},"bonjour")," message is sent. With this message all ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatchers")," in a network register themselves. If such a message is sent, all other dispatchers report their current status. Thus all dispatchers are known to each other."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," checks their status time-based. To do this, all the ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManagers")," send each other a ",(0,i.kt)("inlineCode",{parentName:"p"},"live")," message (a ",(0,i.kt)("inlineCode",{parentName:"p"},"heartbeat"),") defined time interval. This can be used to monitor when a dispatcher last checked in. If this exceeds a certain time interval, that dispatcher is first classified as 'slow' and then as 'dead'. If the dispatcher does not check in after a defined time interval, it is removed."),(0,i.kt)("p",null,"The described changes can be observed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatchers")," property."),(0,i.kt)("p",null,"In addition, the ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," allows synchronization of timestamps with other systems (usually other dispatchers). This is useful when different systems store sensor data, for example. The timestamp is calculated with a delay, which can be determined with pings."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can get a sync timestamp using the ",(0,i.kt)("inlineCode",{parentName:"li"},"now")," property.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," provides properties that simplify the collection of some information:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getStatus")," to get the status of a particular dispatcher."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAllHosts"),": to get all hosts on the network. (It is possible that several nope runtimes are running on the same host)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upTime"),": since when the Connectivity Manager is running. ")),(0,i.kt)("h2",{id:"master"},"Master"),(0,i.kt)("p",null,"Sometimes it is useful to define a ",(0,i.kt)("inlineCode",{parentName:"p"},"master")," in the network with nope runtime, (e.g. time synchronization). For this the flag ",(0,i.kt)("inlineCode",{parentName:"p"},"master")," can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". This sets the master mode of the ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," manually. If it is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", the master is determined automatically and the ",(0,i.kt)("inlineCode",{parentName:"p"},"connectivityManager")," could be a master. The selection of the master is based on the operation time and the connection time."),(0,i.kt)("p",null,"Defaultly a ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager")," is selected as ",(0,i.kt)("inlineCode",{parentName:"p"},"master"),". The master is defined as the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager")," with the highest ",(0,i.kt)("inlineCode",{parentName:"p"},"upTime"),". "),(0,i.kt)("h2",{id:"synchronizing-time"},"Synchronizing time"),(0,i.kt)("p",null,"Because we asume, that ",(0,i.kt)("strong",{parentName:"p"},"NoPE")," is running on different computing nodes, we have to be able to synchronize the time between those elements. Therefore the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectivityManager")," is able to sync the time (by providing a ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp")," and an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," that was needed to get to the call (for instance ",(0,i.kt)("inlineCode",{parentName:"p"},"ping / 2"),"))"),(0,i.kt)("h2",{id:"working-with-a-connectivitymanager"},"Working with a ConnectivityManager"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// First lets install nope using npm\nconst nope = require("nope-js-node")\n\n// Create a communicator:\n// We will use the event layer (which just runs internally)\nconst communicator = nope.getLayer("event");\n\n// Lets create our dispatcher\n\n// 1. Dispatcher simulates our local system\nconst localDispatcher = nope.dispatcher.getDispatcher({\n  communicator,\n  id: "local"\n}, {\n  singleton: false,\n  useBaseServices: false\n});\n\n// Lets wait for our element to be ready.\nawait localDispatcher.ready.waitFor()\n')),(0,i.kt)("p",null,"Now we want to listen to newly connected dispatchers. For this purpose, we create an observer, which will listen to changes. The connectivityManager provides some ",(0,i.kt)("a",{parentName:"p",href:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/observables"},(0,i.kt)("strong",{parentName:"a"},"observables"))," and ",(0,i.kt)("a",{parentName:"p",href:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/eventemitters"},(0,i.kt)("strong",{parentName:"a"},"eventemitters"))," that we can use to get these updates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// Subscribe to changes\nconst observer = localDispatcher.connectivityManager.dispatchers.onChange.subscribe(data => {\n  // Log the changes\n  console.log((new Date()).toISOString(),"onChange - listener");\n  console.log("\\tadded   =", data.added);\n  console.log("\\tremoved =", data.removed);\n});\n')),(0,i.kt)("p",null,"Additionally we want to show the currently connected dispatchers. In this data the own dispatcher will ",(0,i.kt)("strong",{parentName:"p"},"allways")," be included:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// Show our connected Dispatchers\nlet connectedDispatchers = localDispatcher.connectivityManager.dispatchers.data.getContent();\nlet localDispatcherIncluded = connectedDispatchers.includes(localDispatcher.id);\n\n// Now lets log our results.\nconsole.log("connectedDispatchers    =", connectedDispatchers);\nconsole.log("localDispatcherIncluded =", localDispatcherIncluded);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"connectedDispatchers    = [ 'local' ]\nlocalDispatcherIncluded = true\n")),(0,i.kt)("p",null,"Now that we have implemented our listeners and have seen the connected dispatchers (which is only the ",(0,i.kt)("inlineCode",{parentName:"p"},'"local"'),"-dispatchre), We will add an additional dispatcher. This should result in calling our ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange"),"-listener. Additionally, we wait until our ",(0,i.kt)("inlineCode",{parentName:"p"},"remoteDispatcher")," is initalized"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// 2. Dispatcher simulates our remote system\nconst remoteDispatcher = nope.dispatcher.getDispatcher({\n  communicator,\n  id: "remote"\n}, {\n  singleton: false,\n  useBaseServices: false\n});\n\n')),(0,i.kt)("p",null,"This will print:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2023-04-20T07:39:08.596Z onChange - listener\n    added   = [ 'remote' ]\n    removed = []\n")),(0,i.kt)("p",null,"Now we want to see, which system is the current master. This should be our ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// We expect to be the master, because the localDispatcher has been created first.\nconsole.log("master =", localDispatcher.connectivityManager.master.id);\n')),(0,i.kt)("p",null,"This will print:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"master = local\n")),(0,i.kt)("p",null,"We can now force the remote dispatcher to be our master, by setting the master. (For this purpose we can later use a base service ==> then we just have to call the service) "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'\nremoteDispatcher.connectivityManager.isMaster = true;\nlocalDispatcher.connectivityManager.isMaster = false;\n\n// Our messaging is async ==> we wait an amount of time (here 1000 ms)\nawait nope.sleep(1000)\n\n// We expect the master to be the remote.\nconsole.log("master =", localDispatcher.connectivityManager.master.id);\nconsole.log("master-info =", localDispatcher.connectivityManager.master);\n')),(0,i.kt)("p",null,"This will print:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"master = remote\nmaster-info = {\n  id: 'remote',\n  env: 'typescript',\n  version: '1.0.0',\n  isMaster: true,\n  isMasterForced: true,\n  host: {\n    cores: 8,\n    cpu: {\n      model: 'Intel(R) Core(TM) i7-8565U CPU',\n      speed: 1992,\n      usage: 0.023193359375\n    },\n    os: 'win32',\n    ram: { usedPerc: 0.2777418501514157, free: 23432, total: 32442 },\n    name: 'nz-078'\n  },\n  pid: 6644,\n  timestamp: 1681976351645,\n  connectedSince: 1681976348594,\n  status: 0,\n  plugins: []\n}\n")),(0,i.kt)("p",null,"Now lets see what happens if we adapt the heartbeat intervall of our ",(0,i.kt)("em",{parentName:"p"},"local")," instance. We want to receive every 50 ms a heartbeat:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// We define a function, which will render the \n// connection status.\n\nconst renderStatus = () => {\n  console.log((new Date()).toISOString(),"master-info =", localDispatcher.connectivityManager.master.status)\n}\n\nsetTimeout(renderStatus, 50);\nsetTimeout(renderStatus, 750);\nsetTimeout(renderStatus, 1500);\nsetTimeout(renderStatus, 2500);\n\n// Now we adapt the timings of both dispatchers:\n\n\nlocalDispatcher.connectivityManager.setTimings({\n  // our system will send every 50 ms an heartbeat.\n  sendAliveInterval: 250,\n  // we will check that after\n  checkInterval: 125,\n  // will mark dispatchers as slow after not receiving heartbeats for 50ms\n  slow: 500,\n  // we will mark  dispatchers with a warning flag after 50 ms\n  warn: 1000,\n  // we mark it as dead after 0.5 s\n  dead: 2000,\n  // We will remove the dispatcher after 1 s\n  remove: 3000,\n});\n\nremoteDispatcher.connectivityManager.setTimings({\n  // our system will send every 50 ms an heartbeat.\n  sendAliveInterval: 5000,\n});\n\n// We reset the timeouts.\nsetTimeout(() => localDispatcher.connectivityManager.setTimings({}), 3000);\nsetTimeout(() => remoteDispatcher.connectivityManager.setTimings({}), 3000);\n\n')),(0,i.kt)("p",null,"This will print:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2023-04-20T07:39:13.474Z master-info = 0\n2023-04-20T07:39:14.161Z master-info = 1\n2023-04-20T07:39:14.913Z master-info = 2\n2023-04-20T07:39:15.911Z master-info = 3\n2023-04-20T07:39:16.302Z onChange - listener\n    added   = []\n    removed = [ 'remote' ]\n2023-04-20T07:39:16.926Z onChange - listener\n    added   = [ 'remote' ]\n    removed = []\n")),(0,i.kt)("p",null,"As we can see, the dispatcher, that uses a slower heartbeat rate (in the example the ",(0,i.kt)("inlineCode",{parentName:"p"},"remote"),") is marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"slow")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"warning")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"dead")," and is removed afterwards!"))}h.isMDXComponent=!0}}]);