"use strict";(self.webpackChunkopensource_website=self.webpackChunkopensource_website||[]).push([[183],{3905:(t,e,a)=>{a.d(e,{Zo:()=>u,kt:()=>b});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function s(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?s(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},s=Object.keys(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var l=n.createContext({}),p=function(t){var e=n.useContext(l),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},u=function(t){var e=p(t.components);return n.createElement(l.Provider,{value:e},t.children)},d="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,s=t.originalType,l=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),d=p(a),h=r,b=d["".concat(l,".").concat(h)]||d[h]||c[h]||s;return a?n.createElement(b,i(i({ref:e},u),{},{components:a})):n.createElement(b,i({ref:e},u))}));function b(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var s=a.length,i=new Array(s);i[0]=h;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=t,o[d]="string"==typeof t?t:r,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8518:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const s={sidebar_position:7},i="7. Data-Distributor",o={unversionedId:"help/Tutorials/nodejs/basics/data-distributor",id:"help/Tutorials/nodejs/basics/data-distributor",title:"7. Data-Distributor",description:"The DataDistributor essentially represents a DataPubSubSystem. It distributes data over the NoPE network (or internally). Data is manipulated via JSON pointers (these are structured like MQTT topics; see above). In order to inform systems about changes, subscribers can be informed about changes like in MQTT. The wildcards of MQTT can be used to get the relevant information. I.e.:",source:"@site/docs/help/Tutorials/nodejs/03-basics/07-data-distributor.md",sourceDirName:"help/Tutorials/nodejs/03-basics",slug:"/help/Tutorials/nodejs/basics/data-distributor",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/data-distributor",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"6. Event-Distributor",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/event-distributor"},next:{title:"8. RPC-Manager",permalink:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/rpc-manager"}},l={},p=[{value:"DataPubSubSystem",id:"datapubsubsystem",level:2},{value:"Interact with the DataDistributor",id:"interact-with-the-datadistributor",level:2},{value:"Subscribing to data Changes",id:"subscribing-to-data-changes",level:2},{value:"Accessing specific datapoints",id:"accessing-specific-datapoints",level:2}],u={toc:p},d="wrapper";function c(t){let{components:e,...a}=t;return(0,r.kt)(d,(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"7-data-distributor"},"7. Data-Distributor"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"DataDistributor")," essentially represents a ",(0,r.kt)("inlineCode",{parentName:"p"},"DataPubSubSystem"),". It distributes data over the NoPE network (or internally). Data is manipulated via JSON pointers (these are structured like MQTT topics; see above). In order to inform systems about changes, ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribers")," can be informed about changes like in MQTT. The wildcards of MQTT can be used to get the relevant information. I.e.:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"DataDistributor")," contains a ",(0,r.kt)("inlineCode",{parentName:"li"},"root")," data object.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"root")," data object can be modified via paths (similar to topics) (see methods ",(0,r.kt)("inlineCode",{parentName:"li"},"patternBasedPush")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"pushData"),")"))),(0,r.kt)("li",{parentName:"ul"},"If the data object is manipulated, all changes are automatically forwarded to the interested ",(0,r.kt)("inlineCode",{parentName:"li"},"subscribers"),"."),(0,r.kt)("li",{parentName:"ul"},"The naming of the methods corresponds to the push and pull principle ")),(0,r.kt)("h2",{id:"datapubsubsystem"},"DataPubSubSystem"),(0,r.kt)("p",null,"A data based publish and subscribe system.\nIt extends the PubSubSystem by providing the methods and properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pushData")," to push data into the system."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pullData")," to pull data from the system. It always returns the current data or the default value if there is no data under the specified path."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"patternbasedPullData")," to fetch data with a specific pattern. See the example for details."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"patternBasedPush")," to push data with a given pattern into the system."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data"),": direct access to the ",(0,r.kt)("inlineCode",{parentName:"li"},"root")," data object. This object is continuously present and always contains the most recent data manipulated by changes (see ",(0,r.kt)("inlineCode",{parentName:"li"},"patternBasedPush")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"pushData"),").")),(0,r.kt)("h2",{id:"interact-with-the-datadistributor"},"Interact with the DataDistributor"),(0,r.kt)("p",null,"Firstly we have to create a Dispatcher, that we are using to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"dataDistributor")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// First lets install nope using npm\nimport * as nope from "nope-js-node";\n\n// Create a communicator:\n// We will use the event layer (which just runs internally)\nconst communicator = nope.getLayer("event");\n\n// Lets create our dispatcher\n\n// 1. Dispatcher simulates our local system\nconst localDispatcher = nope.dispatcher.getDispatcher({\n  communicator,\n  id: "local"\n}, {\n  singleton: false,\n  useBaseServices: false\n});\n\n// Lets wait for our element to be ready.\nawait localDispatcher.ready.waitFor();\n\n// Create a short cut:\nconst dataDistributor = localDispatcher.dataDistributor;\n')),(0,r.kt)("p",null,"We are now ready to manipulate some data in the system:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// Now we manipulate the data:\ndataDistributor.pushData("", { robot: {status: {state:"waiting", speed:0}}});\n// Render the Root Object. (Read only)\ndataDistributor.data\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"root")," object contains:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{ robot: { status: { state: 'waiting', speed: 0 } } }\n")),(0,r.kt)("h2",{id:"subscribing-to-data-changes"},"Subscribing to data Changes"),(0,r.kt)("p",null,"We are now interessed in data changes. We want allways be informed about the status of a specific object."),(0,r.kt)("p",null,"Therefore we create an subscription of on the topic ",(0,r.kt)("inlineCode",{parentName:"p"},"robot/status"),". By subscribing, we will immediately receive an update containing the current status:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const observer = dataDistributor.registerSubscription("robot/status", (data) => {\n    console.log("The Robot-Status is",data)\n})\n')),(0,r.kt)("p",null,"Executing the code above result in the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The Robot-Status is { state: 'waiting', speed: 0 }\n")),(0,r.kt)("p",null,"We now simulate a change of the robots speed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// We create an extra Element describing the status.\n// We use an observable for that purpose\n\nconst robotStatus = new nope.NopeObservable();\nrobotStatus.setContent({state:"waiting", speed:0});\n\ndataDistributor.register(robotStatus, {\n    mode: "publish",\n    topic: "robot/status"\n});\n\n// Now we adapt the status\n\nrobotStatus.getContent().speed = 1;\nrobotStatus.getContent().state = "moving";\n')),(0,r.kt)("p",null,"Registering the ",(0,r.kt)("inlineCode",{parentName:"p"},"robotStatus")," results in triggering the subscription:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The Robot-Status is { state: 'waiting', speed: 0 }\n")),(0,r.kt)("p",null,"As we can see, we didnt receive an update. Thats based on the behavior of the observable. We have to trigger an update manually right now, or must use the method ",(0,r.kt)("inlineCode",{parentName:"p"},"setContent")," instead of adapting the data object directly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'robotStatus.forcePublish();\n\n// Alternative:\nrobotStatus.setContent({state:"moving", speed:1});\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The Robot-Status is { state: 'moving', speed: 1 }\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"But why didn't receive 2 updates? we used the method ",(0,r.kt)("inlineCode",{parentName:"p"},"forcePublish")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setContent")," and assigned a new status-object, but didnt receive 2 notifications. This is related to the behavior of observables. They only emit changes, if the data really changed (what wasnt the case)")),(0,r.kt)("h2",{id:"accessing-specific-datapoints"},"Accessing specific datapoints"),(0,r.kt)("p",null,"If we want to manipulate data we can use the method ",(0,r.kt)("inlineCode",{parentName:"p"},"pushData"),". Lets add an additional status of an sensor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'dataDistributor.pushData("sensor", {status: {state:"waiting"}});\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"root")," object of the dataDistributor can be read with the property ",(0,r.kt)("inlineCode",{parentName:"p"},"data")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"dataDistributor.data\n")),(0,r.kt)("p",null,"The content of the ",(0,r.kt)("strong",{parentName:"p"},"root")," object is now:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{\n  robot: { status: { state: 'moving', speed: 1 } },\n  sensor: { status: { state: 'waiting' } }\n}\n")),(0,r.kt)("p",null,"If we want to access specific data points inside of the dataDistributor, we can use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"pullData")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"patternBasedPullData")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// pull the data of the sensor:\ndataDistributor.pullData("sensor",false)\n')),(0,r.kt)("p",null,"The pull commands extract the following data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{ status: { state: 'waiting' } }\n")),(0,r.kt)("p",null,"If the data is not present, you can provide an default value, which will be return instead.\nOtherwise an Error is thrown."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// Data that is not present\ndataDistributor.pullData("not_contained", "default-value")\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If no data is present, the default value is returned!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"'default-value'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// Accessing data with a pattern\ndataDistributor.patternbasedPullData("+/status/state")\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Patterns can be used to pull data. The method will allways return a list (it might be empty.)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[\n  { path: 'robot/status/state', data: 'moving' },\n  { path: 'sensor/status/state', data: 'waiting' }\n]\n")),(0,r.kt)("p",null,"As you can see, we receive an array, which contains the object containing:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"path")," of the data"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"data"))),(0,r.kt)("p",null,"Additionally you are able to manipulate data using a path with wildcards, which will trigger our subscriptions as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'dataDistributor.patternBasedPush("+/status/state", "manipulated!")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The Robot-Status is { state: 'manipulated!', speed: 1 }\n")),(0,r.kt)("p",null,"If we look at the data again, we have manipulated the state of the sensor and robot"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"dataDistributor.data\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{\n  robot: { status: { state: 'manipulated!', speed: 1 } },\n  sensor: { status: { state: 'manipulated!' } }\n}\n")),(0,r.kt)("p",null,"Like the ",(0,r.kt)("inlineCode",{parentName:"p"},"eventDistributor")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"dataDistributor")," shares those changes with all runtimes in the network. For this purpose please check the docu of the ",(0,r.kt)("a",{parentName:"p",href:"/NoPE-Docs/docs/help/Tutorials/nodejs/basics/event-distributor"},(0,r.kt)("inlineCode",{parentName:"a"},"eventDistributor"))))}c.isMDXComponent=!0}}]);